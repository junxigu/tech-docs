<!doctype html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<style>
h1,
h2,
h3,
h4,
h5,
h6,
p,
blockquote {
    margin: 0;
    padding: 0;
}
body {
    font-family: "Helvetica Neue", Helvetica, "Hiragino Sans GB", Arial, sans-serif;
    font-size: 13px;
    line-height: 18px;
    color: #737373;
    background-color: white;
    margin: 10px 13px 10px 13px;
}
table {
	margin: 10px 0 15px 0;
	border-collapse: collapse;
}
td,th {	
	border: 1px solid #ddd;
	padding: 3px 10px;
}
th {
	padding: 5px 10px;	
}

a {
    color: #0069d6;
}
a:hover {
    color: #0050a3;
    text-decoration: none;
}
a img {
    border: none;
}
p {
    margin-bottom: 9px;
}
h1,
h2,
h3,
h4,
h5,
h6 {
    color: #404040;
    line-height: 36px;
}
h1 {
    margin-bottom: 18px;
    font-size: 30px;
}
h2 {
    font-size: 24px;
}
h3 {
    font-size: 18px;
}
h4 {
    font-size: 16px;
}
h5 {
    font-size: 14px;
}
h6 {
    font-size: 13px;
}
hr {
    margin: 0 0 19px;
    border: 0;
    border-bottom: 1px solid #ccc;
}
blockquote {
    padding: 13px 13px 21px 15px;
    margin-bottom: 18px;
    font-family:georgia,serif;
    font-style: italic;
}
blockquote:before {
    content:"\201C";
    font-size:40px;
    margin-left:-10px;
    font-family:georgia,serif;
    color:#eee;
}
blockquote p {
    font-size: 14px;
    font-weight: 300;
    line-height: 18px;
    margin-bottom: 0;
    font-style: italic;
}
code, pre {
    font-family: Monaco, Andale Mono, Courier New, monospace;
}
code {
    background-color: #fee9cc;
    color: rgba(0, 0, 0, 0.75);
    padding: 1px 3px;
    font-size: 12px;
    -webkit-border-radius: 3px;
    -moz-border-radius: 3px;
    border-radius: 3px;
}
pre {
    display: block;
    padding: 14px;
    margin: 0 0 18px;
    line-height: 16px;
    font-size: 11px;
    border: 1px solid #d9d9d9;
    white-space: pre-wrap;
    word-wrap: break-word;
}
pre code {
    background-color: #fff;
    color:#737373;
    font-size: 11px;
    padding: 0;
}
sup {
    font-size: 0.83em;
    vertical-align: super;
    line-height: 0;
}
* {
	-webkit-print-color-adjust: exact;
}
@media screen and (min-width: 914px) {
    body {
        width: 854px;
        margin:10px auto;
    }
}
@media print {
	body,code,pre code,h1,h2,h3,h4,h5,h6 {
		color: black;
	}
	table, pre {
		page-break-inside: avoid;
	}
}
</style>
<title>快速入门和浅尝</title>

</head>
<body>
<p><strong>本文是对Junit4各种功能的简单汇总和简述，目标读者是想了解一下Junit4了哪些测试工具的人员，所有代码和技术细节都是参考<a href="https://github.com/junit-team/junit4/wiki#junit-usage-and-idioms">Junit Wiki</a></strong></p>

<hr />

<h1>快速入门和浅尝</h1>

<p>此处不细说，直接参考简单明了的<a href="https://github.com/junit-team/junit4/wiki/Getting-started">Wiki</a>吧，里面的内容就是Junit4 jar包的使用和运行简单测试实例，10分钟即可完成入门</p>

<h1>Junit4功能汇总和简述</h1>

<p>Junit4几乎所有功能官方汇总列表，可从此了解Junit4的各种功能，<a href="https://github.com/junit-team/junit4/wiki">官方Wiki</a>相当简洁明了</p>

<p>此处对较重要的功能稍微汇总，若有感兴趣的功能可到官方Wiki进一步了解：注意 所有代码出自Junit4 wiki</p>

<h2>Assertions和Matchers</h2>

<p><a href="https://github.com/junit-team/junit4/wiki/Assertions">用法详情</a>
这两种功能都是单元测试的技术基石，用来开发单元测试的断言，例如：</p>

<h5>常用Assertion之一：断言text == text</h5>

<p><code>assertEquals("text", "text");</code></p>

<p>注意：参数1是期望值，参数2是实际值</p>

<h5>常用Matchers：allOf, equalTo, startsWith</h5>

<p><code>assertThat("good", allOf(equalTo("good"), startsWith("good")));</code></p>

<p>Matchers都用在assertThat断言中，代码的意思是：此处断言”good” 同时满足所有条件，条件分别是：与“good”相同，以“good”开头</p>

<p><strong>Matchers好处是：更符合断言语序，Matchers表达的比较语义更丰富和灵活，也易于开发人员扩展</strong>
<a href="https://github.com/junit-team/junit4/wiki/Matchers-and-assertthat">用法详情</a></p>

<p><em>另：要测试 <a href="https://github.com/junit-team/junit4/wiki/Exception-testing">异常情况</a> 是否符合预期行为;
要测试 <a href="https://github.com/junit-team/junit4/wiki/Timeout-for-tests">超时</a> 是否符合预期行为</em></p>

<h2>测试用例的运行前初始化和运行后资源清理</h2>

<p><a href="https://github.com/junit-team/junit4/wiki/Test-fixtures">用法详情</a>
主要使用<strong>@BeforeClass，@AfterClass, @Before 和 @After</strong>来标注方法，这些标注都很容易理解</p>

<ul>
<li>@BeforeClass: 标注static类方法，用于对单元测试类中所有case都是用的资源进行初始化（一般用于初始化高成本资源），每个单元测试类只会运行一次</li>
<li>@AfterClass**：同上，功能是释放资源</li>
<li>@Before**：标注实例方法（单元测试用例）,用于对在每个单元测试用例运行前初始化一些变量或资源</li>
<li>@After**：同上，功能是释放资源</li>
</ul>


<h2>测试用例启动器</h2>

<p>顾名思义，这些官方的启动器负责启动开发人员开发的测试用例，你可以根据用例所需要的不同功能来选择不同的启动器，官方的启动器有4个，不满足需求可以自己扩展；
此处稍微汇总
<a href="https://github.com/junit-team/junit4/wiki/Test-runners">用法详情</a></p>

<p><strong>IDE内置的单元测试启动器</strong>：Eclipse，Netbeans等内置了</p>

<p><strong>通过命令行启动单元测试的启动器</strong>：org.junit.runner.JUnitCore；使用的时候直接在命令行窗口跑单元测试
<strong>** JUnit4TestAdapter</strong>: 在Junit3的启动器中运行 用Junit4开发的单元测试 时使用的Junit4启动器adapter</p>

<p><strong>使用@RunWith来注解的class来作为单元测试启动器</strong>：可以在注解里赋值来指定Junit内置的几个启动器，例如：</p>

<p><em>1. 把一堆单元测试用例定义成一整套单元测试</em> <a href="https://github.com/junit-team/junit4/wiki/Aggregating-tests-in-suites">用法详情</a>*</p>

<pre><code>@RunWith(Suite.class) // Sute.class是Junit的启动器
@Suite.SuiteClasses({  //里面的class都是开发人员开发的一些单元测试
    TestFeatureLogin.class,
    TestFeatureLogout.class,
    TestFeatureNavigate.class,
    TestFeatureUpdate.class
})
public class FeatureTestSuite {
    // the class remains empty,
    // used only as a holder for the above annotations
}
</code></pre>

<p><em>2. 给一个测试用例提供不同的参数</em> <a href="https://github.com/junit-team/junit4/wiki/Parameterized-tests">用法详情</a></p>

<pre><code>@RunWith(Parameterized.class)
public class FibonacciTest {
    @Parameters
    public static Collection&lt;Object[]&gt; data() {
        return Arrays.asList(new Object[][] {     
                 { 0, 0 }, { 1, 1 }, { 2, 1 }, { 3, 2 }, { 4, 3 }, { 5, 5 }, { 6, 8 }  
           });
    }

    private int fInput;

    private int fExpected;

    public FibonacciTest(int input, int expected) {
        fInput= input;
        fExpected= expected;
    }

    @Test
    public void test() {
        assertEquals(fExpected, Fibonacci.compute(fInput));
    }
}
</code></pre>

<p><em>3. 把不同的单元测试用例弄成不同分类，然后使用 分类启动器 启动不同类别的单元测试</em> <a href="https://github.com/junit-team/junit4/wiki/Categories">用法详情</a></p>

<p><em>4. 还有一些其他实验性和第三方启动器</em> <a href="https://github.com/junit-team/junit4/wiki/Test-runners#experimental-runners">用法详情</a></p>

<p><em>5. 理论启动器：用于启动使用了“理论”技术开发单元测试的启动器，可参考下文对理论的简述</em> <a href="https://github.com/junit-team/junit4/wiki/Theories">用法详情</a></p>

<h2>开发单元测试时，一些可重用的Junit功能组件的</h2>

<p><a href="https://github.com/junit-team/junit4/wiki/Rules">用法详情</a>
通过@Rule注解来标注所使用的 组件，例如：</p>

<pre><code>@Rule
public TemporaryFolder tempFolder = new TemporaryFolder();
</code></pre>

<p>Rule的原理是Junit在初始化一个单元测试类的时候会实例化一个@Rule标注的 rule域实例，并在每个case运行的时候都会调用 rule域实例的evaluate方法</p>

<p>Junit所提供的组件包括：</p>

<ul>
<li>TemporaryFolder：提供在测试时生成临时目录和文件的功能组件</li>
<li>ExternalResource：提供在测试时 自定义一些外部资源（数据库连接，socket等） 的基类，实现它提供具体的资源</li>
<li>ErrorCollector：测试过程中对 自认为的错误状态进行收集的工具</li>
<li>Verifier：提供 自定义条件校验器 的基类，实现它提供具体的校验</li>
<li>TestWatcher：使用它能在Junit运行每个单元测试用例的每个步骤时得到通知，从而收集用例的测试状态信息</li>
<li>TestName：获取测试用例名称</li>
<li>Timeout：测试 超时 是否符合预期行为</li>
<li>ExpectedException：测试 异常情况 是否符合预期行为</li>
<li>ClassRule：标注类的域，一般是定义一些对整个单元测试类的所有单元测试用例都有影响的域（例如外部资源等），这里不细述，请参考<a href="https://github.com/junit-team/junit4/wiki/Rules">用法详情</a></li>
<li>RuleChain：声明Rule链，链里的Rule是有顺序的</li>
<li>另外，可以实现TestRule接口来定制自己的Rule</li>
</ul>


<h2>理论：一种针对给一个单元测试用例定义各种可能的输入和前置条件的技术</h2>

<p><a href="https://github.com/junit-team/junit4/wiki/Theories">用法详情</a>
使用这种启动器，你可以定义测试用例的所有前置条件（不满足前置条件则忽略这个测试用例），以及不同的测试输入参数</p>

<hr />

<h1>Junit的其他常用技术：</h1>

<ul>
<li><a href="https://github.com/junit-team/junit4/wiki/Ignoring-tests">忽略（跳过）某些测试用例</a></li>
<li><a href="https://github.com/junit-team/junit4/wiki/Assumptions-with-assume">对测试用例定义运行的先决条件 assumptions（不满足会自动跳过测试用例</a></li>
<li><a href="https://github.com/junit-team/junit4/wiki/Multithreaded-code-and-concurrency">多线程，并发测试</a></li>
<li><a href="https://github.com/junit-team/junit4/wiki/Continuous-testing">持续集成和测试</a></li>
<li><a href="https://github.com/junit-team/junit4/wiki#junit-usage-and-idioms">maven和grade</a></li>
</ul>

</body>
</html>